<div id="wrapper">
    <div id="filter_box">
        <form on:submit="activateTopTab()">
            <input type="search"
                ref:filterbox 
                bind:value="filter"
                placeholder="Filter...">
        </form>
    </div>
    {{#await filtered_windows}}
    <p>Loading...</p>
    {{then answer}}
    {{#each answer as win}}
    <div class="window">
        <h3>{{ win.title }}</h3>
        {{#each win.tabs as tab}}
        <div class="tab">
            {{#if tab.favIconUrl}}
            <img src="{{ tab.favIconUrl }}" alt="favicon" width="16" height="16">
            {{else}}
            <img src="static/tab.png" alt="no favicon" width="16" height="16">
            {{/if}}
            {{ tab.title }}
            {{#if tab.container}}
            <span style="color: {{ tab.container.colorCode }}">
                <img src="{{ tab.container.iconUrl }}" alt="container" width="16" height="16">
                {{ tab.container.name }}
            </span>
            {{/if}}
        </div>
        {{/each}}
    </div>
    {{/each}}
    {{catch error}}
    <p>An error occured!</p>
    <pre>{{ error }}</pre>
    {{/await}}
</div>

<style>
    #wrapper {
        display: flex;
        flex-direction: column;
        width: 500px;
        height: 500px;
        padding: 10px;
    }

    .window {
        width: 100%;
        display: flex;
        flex-direction: column;
    }

    .tab {
        padding-left: 10px;
        display: flex;
        align-items: center;
        flex-direction: row;
    }

    .tab > * {
        margin-right: 5px;
    }
</style>

<script>
    export default {
        data () {
            return {
                windows: browser.windows.getAll({
                    populate: true,
                    windowTypes: ['normal']
                }),
                containers: browser.contextualIdentities.query({}),
                filter: ""
            };
        },

        computed: {
            containers_by_id: containers => {
                return containers.then(contexts => {
                    let containers = {};
                    for (let i = 0; i < contexts.length; i++) {
                        containers[contexts[i].cookieStoreId] = contexts[i];
                    }
                    return containers;
                })
            },
            complete_windows: (windows, containers_by_id) => {
                return Promise.all([windows, containers_by_id])
                    .then(([windows, containers]) => {
                        for (let i = 0; i < windows.length; i++) {
                            for (let j = 0; j < windows[i].tabs.length; j++) {
                                const container_id = windows[i].tabs[j].cookieStoreId;
                                if (container_id && containers.hasOwnProperty(container_id)) {
                                    windows[i].tabs[j].container = containers[container_id];
                                }
                            }
                        }
                        return windows;
                    });
            },
            filtered_windows: (complete_windows, filter) => {
                if (filter.length == 0) {
                    return complete_windows;
                }
                return complete_windows.then(windows => {
                    let new_windows = [];
                    const regex = new RegExp(filter, 'i');
                    for (let i = 0; i < windows.length; i++) {
                        let temp = [];
                        for (let j = 0; j < windows[i].tabs.length; j++) {
                            if (windows[i].tabs[j].title.match(regex)) {
                                temp.push(windows[i].tabs[j]);
                            }
                        }

                        if (temp.length > 0) {
                            new_windows.push({
                                tabs: temp,
                                title: windows[i].title
                            });
                        }
                    }

                    return new_windows;
                });
            }
        },

        oncreate () {
            this.refs.filterbox.focus();
        },

        methods: {
            activateTab: function(tab_id) {
                browser.tabs.update(tab_id, { active: true });
                window.close();
            },

            activateTopTab: function() {
                this.get("filtered_windows").then(filtered_windows => {
                    if (filtered_windows.length == 0) {
                        return;
                    }
                    if (filtered_windows[0].tabs.length == 0) {
                        return;
                    }
                    const tab = filtered_windows[0].tabs[0];
                    this.activateTab(tab.id);
                });
            }
        }
    }
</script>
